/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/@solana/spl-token@0.1.8/lib/index.cjs.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _defineProperty=require("@babel/runtime/helpers/defineProperty"),buffer=require("buffer"),assert=require("assert"),BN=require("bn.js"),BufferLayout=require("buffer-layout"),web3_js=require("@solana/web3.js");function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var i=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,i.get?i:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var _defineProperty__default=_interopDefaultLegacy(_defineProperty),assert__default=_interopDefaultLegacy(assert),BN__default=_interopDefaultLegacy(BN),BufferLayout__namespace=_interopNamespace(BufferLayout);const publicKey=(e="publicKey")=>BufferLayout__namespace.blob(32,e),uint64=(e="uint64")=>BufferLayout__namespace.blob(8,e);function sendAndConfirmTransaction(e,t,n,...i){return web3_js.sendAndConfirmTransaction(t,n,i,{skipPreflight:!1})}const TOKEN_PROGRAM_ID=new web3_js.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),ASSOCIATED_TOKEN_PROGRAM_ID=new web3_js.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),FAILED_TO_FIND_ACCOUNT="Failed to find account",INVALID_ACCOUNT_OWNER="Invalid account owner";function pubkeyToBuffer(e){return buffer.Buffer.from(e.toBuffer())}class u64 extends BN__default.default{toBuffer(){const e=super.toArray().reverse(),t=buffer.Buffer.from(e);if(8===t.length)return t;assert__default.default(t.length<8,"u64 too large");const n=buffer.Buffer.alloc(8);return t.copy(n),n}static fromBuffer(e){return assert__default.default(8===e.length,`Invalid buffer length: ${e.length}`),new u64([...e].reverse().map((e=>`00${e.toString(16)}`.slice(-2))).join(""),16)}}function isAccount(e){return"publicKey"in e}const AuthorityTypeCodes={MintTokens:0,FreezeAccount:1,AccountOwner:2,CloseAccount:3},NATIVE_MINT=new web3_js.PublicKey("So11111111111111111111111111111111111111112"),MintLayout=BufferLayout__namespace.struct([BufferLayout__namespace.u32("mintAuthorityOption"),publicKey("mintAuthority"),uint64("supply"),BufferLayout__namespace.u8("decimals"),BufferLayout__namespace.u8("isInitialized"),BufferLayout__namespace.u32("freezeAuthorityOption"),publicKey("freezeAuthority")]),AccountLayout=BufferLayout__namespace.struct([publicKey("mint"),publicKey("owner"),uint64("amount"),BufferLayout__namespace.u32("delegateOption"),publicKey("delegate"),BufferLayout__namespace.u8("state"),BufferLayout__namespace.u32("isNativeOption"),uint64("isNative"),uint64("delegatedAmount"),BufferLayout__namespace.u32("closeAuthorityOption"),publicKey("closeAuthority")]),MultisigLayout=BufferLayout__namespace.struct([BufferLayout__namespace.u8("m"),BufferLayout__namespace.u8("n"),BufferLayout__namespace.u8("is_initialized"),publicKey("signer1"),publicKey("signer2"),publicKey("signer3"),publicKey("signer4"),publicKey("signer5"),publicKey("signer6"),publicKey("signer7"),publicKey("signer8"),publicKey("signer9"),publicKey("signer10"),publicKey("signer11")]);class Token{constructor(e,t,n,i){_defineProperty__default.default(this,"connection",void 0),_defineProperty__default.default(this,"publicKey",void 0),_defineProperty__default.default(this,"programId",void 0),_defineProperty__default.default(this,"associatedProgramId",void 0),_defineProperty__default.default(this,"payer",void 0),Object.assign(this,{connection:e,publicKey:t,programId:n,payer:i,associatedProgramId:ASSOCIATED_TOKEN_PROGRAM_ID})}static async getMinBalanceRentForExemptMint(e){return await e.getMinimumBalanceForRentExemption(MintLayout.span)}static async getMinBalanceRentForExemptAccount(e){return await e.getMinimumBalanceForRentExemption(AccountLayout.span)}static async getMinBalanceRentForExemptMultisig(e){return await e.getMinimumBalanceForRentExemption(MultisigLayout.span)}static async createMint(e,t,n,i,r,a){const s=web3_js.Keypair.generate(),u=new Token(e,s.publicKey,a,t),o=await Token.getMinBalanceRentForExemptMint(e),c=new web3_js.Transaction;return c.add(web3_js.SystemProgram.createAccount({fromPubkey:t.publicKey,newAccountPubkey:s.publicKey,lamports:o,space:MintLayout.span,programId:a})),c.add(Token.createInitMintInstruction(a,s.publicKey,r,n,i)),await sendAndConfirmTransaction("createAccount and InitializeMint",e,c,t,s),u}async createAccount(e){const t=await Token.getMinBalanceRentForExemptAccount(this.connection),n=web3_js.Keypair.generate(),i=new web3_js.Transaction;i.add(web3_js.SystemProgram.createAccount({fromPubkey:this.payer.publicKey,newAccountPubkey:n.publicKey,lamports:t,space:AccountLayout.span,programId:this.programId}));const r=this.publicKey;return i.add(Token.createInitAccountInstruction(this.programId,r,n.publicKey,e)),await sendAndConfirmTransaction("createAccount and InitializeAccount",this.connection,i,this.payer,n),n.publicKey}async createAssociatedTokenAccount(e){const t=await Token.getAssociatedTokenAddress(this.associatedProgramId,this.programId,this.publicKey,e);return this.createAssociatedTokenAccountInternal(e,t)}async createAssociatedTokenAccountInternal(e,t){return await sendAndConfirmTransaction("CreateAssociatedTokenAccount",this.connection,(new web3_js.Transaction).add(Token.createAssociatedTokenAccountInstruction(this.associatedProgramId,this.programId,this.publicKey,t,e,this.payer.publicKey)),this.payer),t}async getOrCreateAssociatedAccountInfo(e){const t=await Token.getAssociatedTokenAddress(this.associatedProgramId,this.programId,this.publicKey,e);try{return await this.getAccountInfo(t)}catch(n){if(n.message===FAILED_TO_FIND_ACCOUNT||n.message===INVALID_ACCOUNT_OWNER){try{await this.createAssociatedTokenAccountInternal(e,t)}catch(e){}return await this.getAccountInfo(t)}throw n}}static async createWrappedNativeAccount(e,t,n,i,r){const a=await Token.getMinBalanceRentForExemptAccount(e),s=web3_js.Keypair.generate(),u=new web3_js.Transaction;return u.add(web3_js.SystemProgram.createAccount({fromPubkey:i.publicKey,newAccountPubkey:s.publicKey,lamports:a,space:AccountLayout.span,programId:t})),u.add(web3_js.SystemProgram.transfer({fromPubkey:i.publicKey,toPubkey:s.publicKey,lamports:r})),u.add(Token.createInitAccountInstruction(t,NATIVE_MINT,s.publicKey,n)),await sendAndConfirmTransaction("createAccount, transfer, and initializeAccount",e,u,i,s),s.publicKey}async createMultisig(e,t){const n=web3_js.Keypair.generate(),i=await Token.getMinBalanceRentForExemptMultisig(this.connection),r=new web3_js.Transaction;r.add(web3_js.SystemProgram.createAccount({fromPubkey:this.payer.publicKey,newAccountPubkey:n.publicKey,lamports:i,space:MultisigLayout.span,programId:this.programId}));let a=[{pubkey:n.publicKey,isSigner:!1,isWritable:!0},{pubkey:web3_js.SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}];t.forEach((e=>a.push({pubkey:e,isSigner:!1,isWritable:!1})));const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),BufferLayout__namespace.u8("m")]),u=buffer.Buffer.alloc(s.span);return s.encode({instruction:2,m:e},u),r.add({keys:a,programId:this.programId,data:u}),await sendAndConfirmTransaction("createAccount and InitializeMultisig",this.connection,r,this.payer,n),n.publicKey}async getMintInfo(){const e=await this.connection.getAccountInfo(this.publicKey);if(null===e)throw new Error("Failed to find mint account");if(!e.owner.equals(this.programId))throw new Error(`Invalid mint owner: ${JSON.stringify(e.owner)}`);if(e.data.length!=MintLayout.span)throw new Error("Invalid mint size");const t=buffer.Buffer.from(e.data),n=MintLayout.decode(t);return 0===n.mintAuthorityOption?n.mintAuthority=null:n.mintAuthority=new web3_js.PublicKey(n.mintAuthority),n.supply=u64.fromBuffer(n.supply),n.isInitialized=0!=n.isInitialized,0===n.freezeAuthorityOption?n.freezeAuthority=null:n.freezeAuthority=new web3_js.PublicKey(n.freezeAuthority),n}async getAccountInfo(e,t){const n=await this.connection.getAccountInfo(e,t);if(null===n)throw new Error(FAILED_TO_FIND_ACCOUNT);if(!n.owner.equals(this.programId))throw new Error(INVALID_ACCOUNT_OWNER);if(n.data.length!=AccountLayout.span)throw new Error("Invalid account size");const i=buffer.Buffer.from(n.data),r=AccountLayout.decode(i);if(r.address=e,r.mint=new web3_js.PublicKey(r.mint),r.owner=new web3_js.PublicKey(r.owner),r.amount=u64.fromBuffer(r.amount),0===r.delegateOption?(r.delegate=null,r.delegatedAmount=new u64):(r.delegate=new web3_js.PublicKey(r.delegate),r.delegatedAmount=u64.fromBuffer(r.delegatedAmount)),r.isInitialized=0!==r.state,r.isFrozen=2===r.state,1===r.isNativeOption?(r.rentExemptReserve=u64.fromBuffer(r.isNative),r.isNative=!0):(r.rentExemptReserve=null,r.isNative=!1),0===r.closeAuthorityOption?r.closeAuthority=null:r.closeAuthority=new web3_js.PublicKey(r.closeAuthority),!r.mint.equals(this.publicKey))throw new Error(`Invalid account mint: ${JSON.stringify(r.mint)} !== ${JSON.stringify(this.publicKey)}`);return r}async getMultisigInfo(e){const t=await this.connection.getAccountInfo(e);if(null===t)throw new Error("Failed to find multisig");if(!t.owner.equals(this.programId))throw new Error("Invalid multisig owner");if(t.data.length!=MultisigLayout.span)throw new Error("Invalid multisig size");const n=buffer.Buffer.from(t.data),i=MultisigLayout.decode(n);return i.signer1=new web3_js.PublicKey(i.signer1),i.signer2=new web3_js.PublicKey(i.signer2),i.signer3=new web3_js.PublicKey(i.signer3),i.signer4=new web3_js.PublicKey(i.signer4),i.signer5=new web3_js.PublicKey(i.signer5),i.signer6=new web3_js.PublicKey(i.signer6),i.signer7=new web3_js.PublicKey(i.signer7),i.signer8=new web3_js.PublicKey(i.signer8),i.signer9=new web3_js.PublicKey(i.signer9),i.signer10=new web3_js.PublicKey(i.signer10),i.signer11=new web3_js.PublicKey(i.signer11),i}async transfer(e,t,n,i,r){let a,s;return isAccount(n)?(a=n.publicKey,s=[n]):(a=n,s=i),await sendAndConfirmTransaction("Transfer",this.connection,(new web3_js.Transaction).add(Token.createTransferInstruction(this.programId,e,t,a,i,r)),this.payer,...s)}async approve(e,t,n,i,r){let a,s;isAccount(n)?(a=n.publicKey,s=[n]):(a=n,s=i),await sendAndConfirmTransaction("Approve",this.connection,(new web3_js.Transaction).add(Token.createApproveInstruction(this.programId,e,t,a,i,r)),this.payer,...s)}async revoke(e,t,n){let i,r;isAccount(t)?(i=t.publicKey,r=[t]):(i=t,r=n),await sendAndConfirmTransaction("Revoke",this.connection,(new web3_js.Transaction).add(Token.createRevokeInstruction(this.programId,e,i,n)),this.payer,...r)}async setAuthority(e,t,n,i,r){let a,s;isAccount(i)?(a=i.publicKey,s=[i]):(a=i,s=r),await sendAndConfirmTransaction("SetAuthority",this.connection,(new web3_js.Transaction).add(Token.createSetAuthorityInstruction(this.programId,e,t,n,a,r)),this.payer,...s)}async mintTo(e,t,n,i){let r,a;isAccount(t)?(r=t.publicKey,a=[t]):(r=t,a=n),await sendAndConfirmTransaction("MintTo",this.connection,(new web3_js.Transaction).add(Token.createMintToInstruction(this.programId,this.publicKey,e,r,n,i)),this.payer,...a)}async burn(e,t,n,i){let r,a;isAccount(t)?(r=t.publicKey,a=[t]):(r=t,a=n),await sendAndConfirmTransaction("Burn",this.connection,(new web3_js.Transaction).add(Token.createBurnInstruction(this.programId,this.publicKey,e,r,n,i)),this.payer,...a)}async closeAccount(e,t,n,i){let r,a;isAccount(n)?(r=n.publicKey,a=[n]):(r=n,a=i),await sendAndConfirmTransaction("CloseAccount",this.connection,(new web3_js.Transaction).add(Token.createCloseAccountInstruction(this.programId,e,t,r,i)),this.payer,...a)}async freezeAccount(e,t,n){let i,r;isAccount(t)?(i=t.publicKey,r=[t]):(i=t,r=n),await sendAndConfirmTransaction("FreezeAccount",this.connection,(new web3_js.Transaction).add(Token.createFreezeAccountInstruction(this.programId,e,this.publicKey,i,n)),this.payer,...r)}async thawAccount(e,t,n){let i,r;isAccount(t)?(i=t.publicKey,r=[t]):(i=t,r=n),await sendAndConfirmTransaction("ThawAccount",this.connection,(new web3_js.Transaction).add(Token.createThawAccountInstruction(this.programId,e,this.publicKey,i,n)),this.payer,...r)}async transferChecked(e,t,n,i,r,a){let s,u;return isAccount(n)?(s=n.publicKey,u=[n]):(s=n,u=i),await sendAndConfirmTransaction("TransferChecked",this.connection,(new web3_js.Transaction).add(Token.createTransferCheckedInstruction(this.programId,e,this.publicKey,t,s,i,r,a)),this.payer,...u)}async approveChecked(e,t,n,i,r,a){let s,u;isAccount(n)?(s=n.publicKey,u=[n]):(s=n,u=i),await sendAndConfirmTransaction("ApproveChecked",this.connection,(new web3_js.Transaction).add(Token.createApproveCheckedInstruction(this.programId,e,this.publicKey,t,s,i,r,a)),this.payer,...u)}async mintToChecked(e,t,n,i,r){let a,s;isAccount(t)?(a=t.publicKey,s=[t]):(a=t,s=n),await sendAndConfirmTransaction("MintToChecked",this.connection,(new web3_js.Transaction).add(Token.createMintToCheckedInstruction(this.programId,this.publicKey,e,a,n,i,r)),this.payer,...s)}async burnChecked(e,t,n,i,r){let a,s;isAccount(t)?(a=t.publicKey,s=[t]):(a=t,s=n),await sendAndConfirmTransaction("BurnChecked",this.connection,(new web3_js.Transaction).add(Token.createBurnCheckedInstruction(this.programId,this.publicKey,e,a,n,i,r)),this.payer,...s)}async syncNative(e){await sendAndConfirmTransaction("SyncNative",this.connection,(new web3_js.Transaction).add(Token.createSyncNativeInstruction(this.programId,e)),this.payer)}static createInitMintInstruction(e,t,n,i,r){let a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:web3_js.SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}];const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),BufferLayout__namespace.u8("decimals"),publicKey("mintAuthority"),BufferLayout__namespace.u8("option"),publicKey("freezeAuthority")]);let u=buffer.Buffer.alloc(1024);{const e=s.encode({instruction:0,decimals:n,mintAuthority:pubkeyToBuffer(i),option:null===r?0:1,freezeAuthority:pubkeyToBuffer(r||new web3_js.PublicKey(0))},u);u=u.slice(0,e)}return new web3_js.TransactionInstruction({keys:a,programId:e,data:u})}static createInitAccountInstruction(e,t,n,i){const r=[{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:web3_js.SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],a=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction")]),s=buffer.Buffer.alloc(a.span);return a.encode({instruction:1},s),new web3_js.TransactionInstruction({keys:r,programId:e,data:s})}static createTransferInstruction(e,t,n,i,r,a){const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount")]),u=buffer.Buffer.alloc(s.span);s.encode({instruction:3,amount:new u64(a).toBuffer()},u);let o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0}];return 0===r.length?o.push({pubkey:i,isSigner:!0,isWritable:!1}):(o.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>o.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:o,programId:e,data:u})}static createApproveInstruction(e,t,n,i,r,a){const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount")]),u=buffer.Buffer.alloc(s.span);s.encode({instruction:4,amount:new u64(a).toBuffer()},u);let o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1}];return 0===r.length?o.push({pubkey:i,isSigner:!0,isWritable:!1}):(o.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>o.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:o,programId:e,data:u})}static createRevokeInstruction(e,t,n,i){const r=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction")]),a=buffer.Buffer.alloc(r.span);r.encode({instruction:5},a);let s=[{pubkey:t,isSigner:!1,isWritable:!0}];return 0===i.length?s.push({pubkey:n,isSigner:!0,isWritable:!1}):(s.push({pubkey:n,isSigner:!1,isWritable:!1}),i.forEach((e=>s.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:s,programId:e,data:a})}static createSetAuthorityInstruction(e,t,n,i,r,a){const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),BufferLayout__namespace.u8("authorityType"),BufferLayout__namespace.u8("option"),publicKey("newAuthority")]);let u=buffer.Buffer.alloc(1024);{const e=s.encode({instruction:6,authorityType:AuthorityTypeCodes[i],option:null===n?0:1,newAuthority:pubkeyToBuffer(n||new web3_js.PublicKey(0))},u);u=u.slice(0,e)}let o=[{pubkey:t,isSigner:!1,isWritable:!0}];return 0===a.length?o.push({pubkey:r,isSigner:!0,isWritable:!1}):(o.push({pubkey:r,isSigner:!1,isWritable:!1}),a.forEach((e=>o.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:o,programId:e,data:u})}static createMintToInstruction(e,t,n,i,r,a){const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount")]),u=buffer.Buffer.alloc(s.span);s.encode({instruction:7,amount:new u64(a).toBuffer()},u);let o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0}];return 0===r.length?o.push({pubkey:i,isSigner:!0,isWritable:!1}):(o.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>o.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:o,programId:e,data:u})}static createBurnInstruction(e,t,n,i,r,a){const s=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount")]),u=buffer.Buffer.alloc(s.span);s.encode({instruction:8,amount:new u64(a).toBuffer()},u);let o=[{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}];return 0===r.length?o.push({pubkey:i,isSigner:!0,isWritable:!1}):(o.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>o.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:o,programId:e,data:u})}static createCloseAccountInstruction(e,t,n,i,r){const a=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction")]),s=buffer.Buffer.alloc(a.span);a.encode({instruction:9},s);let u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0}];return 0===r.length?u.push({pubkey:i,isSigner:!0,isWritable:!1}):(u.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>u.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:u,programId:e,data:s})}static createFreezeAccountInstruction(e,t,n,i,r){const a=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction")]),s=buffer.Buffer.alloc(a.span);a.encode({instruction:10},s);let u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1}];return 0===r.length?u.push({pubkey:i,isSigner:!0,isWritable:!1}):(u.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>u.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:u,programId:e,data:s})}static createThawAccountInstruction(e,t,n,i,r){const a=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction")]),s=buffer.Buffer.alloc(a.span);a.encode({instruction:11},s);let u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1}];return 0===r.length?u.push({pubkey:i,isSigner:!0,isWritable:!1}):(u.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>u.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:u,programId:e,data:s})}static createTransferCheckedInstruction(e,t,n,i,r,a,s,u){const o=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount"),BufferLayout__namespace.u8("decimals")]),c=buffer.Buffer.alloc(o.span);o.encode({instruction:12,amount:new u64(s).toBuffer(),decimals:u},c);let p=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0}];return 0===a.length?p.push({pubkey:r,isSigner:!0,isWritable:!1}):(p.push({pubkey:r,isSigner:!1,isWritable:!1}),a.forEach((e=>p.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:p,programId:e,data:c})}static createApproveCheckedInstruction(e,t,n,i,r,a,s,u){const o=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount"),BufferLayout__namespace.u8("decimals")]),c=buffer.Buffer.alloc(o.span);o.encode({instruction:13,amount:new u64(s).toBuffer(),decimals:u},c);let p=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!1}];return 0===a.length?p.push({pubkey:r,isSigner:!0,isWritable:!1}):(p.push({pubkey:r,isSigner:!1,isWritable:!1}),a.forEach((e=>p.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:p,programId:e,data:c})}static createMintToCheckedInstruction(e,t,n,i,r,a,s){const u=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount"),BufferLayout__namespace.u8("decimals")]),o=buffer.Buffer.alloc(u.span);u.encode({instruction:14,amount:new u64(a).toBuffer(),decimals:s},o);let c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0}];return 0===r.length?c.push({pubkey:i,isSigner:!0,isWritable:!1}):(c.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>c.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:c,programId:e,data:o})}static createBurnCheckedInstruction(e,t,n,i,r,a,s){const u=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"),uint64("amount"),BufferLayout__namespace.u8("decimals")]),o=buffer.Buffer.alloc(u.span);u.encode({instruction:15,amount:new u64(a).toBuffer(),decimals:s},o);let c=[{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}];return 0===r.length?c.push({pubkey:i,isSigner:!0,isWritable:!1}):(c.push({pubkey:i,isSigner:!1,isWritable:!1}),r.forEach((e=>c.push({pubkey:e.publicKey,isSigner:!0,isWritable:!1})))),new web3_js.TransactionInstruction({keys:c,programId:e,data:o})}static createSyncNativeInstruction(e,t){const n=BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction")]),i=buffer.Buffer.alloc(n.span);n.encode({instruction:17},i);let r=[{pubkey:t,isSigner:!1,isWritable:!0}];return new web3_js.TransactionInstruction({keys:r,programId:e,data:i})}static async getAssociatedTokenAddress(e,t,n,i,r=!1){if(!r&&!web3_js.PublicKey.isOnCurve(i.toBuffer()))throw new Error(`Owner cannot sign: ${i.toString()}`);return(await web3_js.PublicKey.findProgramAddress([i.toBuffer(),t.toBuffer(),n.toBuffer()],e))[0]}static createAssociatedTokenAccountInstruction(e,t,n,i,r,a){const s=buffer.Buffer.alloc(0);let u=[{pubkey:a,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:web3_js.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:web3_js.SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}];return new web3_js.TransactionInstruction({keys:u,programId:e,data:s})}}exports.ASSOCIATED_TOKEN_PROGRAM_ID=ASSOCIATED_TOKEN_PROGRAM_ID,exports.AccountLayout=AccountLayout,exports.MintLayout=MintLayout,exports.NATIVE_MINT=NATIVE_MINT,exports.TOKEN_PROGRAM_ID=TOKEN_PROGRAM_ID,exports.Token=Token,exports.u64=u64;
//# sourceMappingURL=/sm/600d08e97a4b19c942abba761677a6220a38b17da65a646e8391271e90cc0358.map